{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Dew/404SquadSolarConnect/final/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma?: PrismaClient\r\n}\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log:\r\n      process.env.NODE_ENV === \"development\"\r\n        ? [\"error\", \"warn\"]\r\n        : [\"error\"],\r\n  })\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  globalForPrisma.prisma = prisma\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KACE,uCACI;QAAC;QAAS;KAAO,GACjB;AACR;AAEF,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B"}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Dew/404SquadSolarConnect/final/lib/session.ts"],"sourcesContent":["import { cookies } from \"next/headers\"\r\nimport crypto from \"crypto\"\r\nimport { prisma } from \"./prisma\"\r\nimport type { Session, User } from \"@prisma/client\"\r\n\r\nconst SESSION_COOKIE = \"session_token\"\r\nconst SESSION_MAX_AGE_SECONDS = 60 * 60 * 24 * 30 // 30 days\r\n\r\nexport type SessionWithUser = Session & {\r\n  user: User & {\r\n    organization: { id: string; name: string; isRejected: boolean } | null\r\n  }\r\n}\r\n\r\nexport function serializeUser(\r\n  user: User & { organization?: { id: string; name: string; isRejected?: boolean } | null },\r\n) {\r\n  const { passwordHash: _passwordHash, ...safeUser } = user\r\n\r\n  return {\r\n    ...safeUser,\r\n    organization: user.organization\r\n      ? {\r\n          id: user.organization.id,\r\n          name: user.organization.name,\r\n          isRejected: Boolean(user.organization.isRejected),\r\n        }\r\n      : null,\r\n  }\r\n}\r\n\r\nexport async function getSession(): Promise<SessionWithUser | null> {\r\n  const cookieStore = await cookies()\r\n  const token = cookieStore.get(SESSION_COOKIE)?.value\r\n  if (!token) return null\r\n\r\n  const session = await prisma.session.findUnique({\r\n    where: { token },\r\n    include: {\r\n      user: {\r\n        include: {\r\n          organization: {\r\n            select: { id: true, name: true, isRejected: true },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  })\r\n\r\n  if (!session) {\r\n    cookieStore.delete(SESSION_COOKIE)\r\n    return null\r\n  }\r\n\r\n  if (session.expiresAt < new Date()) {\r\n    await prisma.session.delete({ where: { token } })\r\n    cookieStore.delete(SESSION_COOKIE)\r\n    return null\r\n  }\r\n\r\n  return session as SessionWithUser\r\n}\r\n\r\nexport async function getCurrentUser() {\r\n  const session = await getSession()\r\n  return session ? serializeUser(session.user) : null\r\n}\r\n\r\nexport async function createSession(userId: string) {\r\n  const token = crypto.randomUUID()\r\n  const expiresAt = new Date(Date.now() + SESSION_MAX_AGE_SECONDS * 1000)\r\n\r\n  await prisma.session.create({\r\n    data: {\r\n      token,\r\n      userId,\r\n      expiresAt,\r\n    },\r\n  })\r\n\r\n  const cookieStore = await cookies()\r\n  cookieStore.set(SESSION_COOKIE, token, {\r\n    httpOnly: true,\r\n    sameSite: \"lax\",\r\n    secure: process.env.NODE_ENV === \"production\",\r\n    maxAge: SESSION_MAX_AGE_SECONDS,\r\n    path: \"/\",\r\n  })\r\n\r\n  return token\r\n}\r\n\r\nexport async function clearSession() {\r\n  const cookieStore = await cookies()\r\n  const token = cookieStore.get(SESSION_COOKIE)?.value\r\n\r\n  if (token) {\r\n    await prisma.session.deleteMany({ where: { token } })\r\n  }\r\n\r\n  cookieStore.delete(SESSION_COOKIE)\r\n}\r\n\r\nexport async function requireUser() {\r\n  const user = await getCurrentUser()\r\n  if (!user) {\r\n    throw new Error(\"UNAUTHENTICATED\")\r\n  }\r\n  return user\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;;;;AAGA,MAAM,iBAAiB;AACvB,MAAM,0BAA0B,KAAK,KAAK,KAAK,GAAG,UAAU;;AAQrD,SAAS,cACd,IAAyF;IAEzF,MAAM,EAAE,cAAc,aAAa,EAAE,GAAG,UAAU,GAAG;IAErD,OAAO;QACL,GAAG,QAAQ;QACX,cAAc,KAAK,YAAY,GAC3B;YACE,IAAI,KAAK,YAAY,CAAC,EAAE;YACxB,MAAM,KAAK,YAAY,CAAC,IAAI;YAC5B,YAAY,QAAQ,KAAK,YAAY,CAAC,UAAU;QAClD,IACA;IACN;AACF;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,6KAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,iBAAiB;IAC/C,IAAI,CAAC,OAAO,OAAO;IAEnB,MAAM,UAAU,MAAM,0JAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAM;QACf,SAAS;YACP,MAAM;gBACJ,SAAS;oBACP,cAAc;wBACZ,QAAQ;4BAAE,IAAI;4BAAM,MAAM;4BAAM,YAAY;wBAAK;oBACnD;gBACF;YACF;QACF;IACF;IAEA,IAAI,CAAC,SAAS;QACZ,YAAY,MAAM,CAAC;QACnB,OAAO;IACT;IAEA,IAAI,QAAQ,SAAS,GAAG,IAAI,QAAQ;QAClC,MAAM,0JAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAAE,OAAO;gBAAE;YAAM;QAAE;QAC/C,YAAY,MAAM,CAAC;QACnB,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,OAAO,UAAU,cAAc,QAAQ,IAAI,IAAI;AACjD;AAEO,eAAe,cAAc,MAAc;IAChD,MAAM,QAAQ,gHAAM,CAAC,UAAU;IAC/B,MAAM,YAAY,IAAI,KAAK,KAAK,GAAG,KAAK,0BAA0B;IAElE,MAAM,0JAAM,CAAC,OAAO,CAAC,MAAM,CAAC;QAC1B,MAAM;YACJ;YACA;YACA;QACF;IACF;IAEA,MAAM,cAAc,MAAM,IAAA,6KAAO;IACjC,YAAY,GAAG,CAAC,gBAAgB,OAAO;QACrC,UAAU;QACV,UAAU;QACV,QAAQ,oDAAyB;QACjC,QAAQ;QACR,MAAM;IACR;IAEA,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,6KAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,iBAAiB;IAE/C,IAAI,OAAO;QACT,MAAM,0JAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAM;QAAE;IACrD;IAEA,YAAY,MAAM,CAAC;AACrB;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM;IACnB,IAAI,CAAC,MAAM;QACT,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Dew/404SquadSolarConnect/final/lib/auth-server.ts"],"sourcesContent":["import { cookies } from \"next/headers\"\r\nimport \"server-only\"\r\nimport { NextResponse } from \"next/server\"\r\nimport { randomUUID } from \"crypto\"\r\nimport { SignJWT, jwtVerify } from \"jose\"\r\nimport bcrypt from \"bcryptjs\"\r\nimport { prisma } from \"./prisma\"\r\nimport { UserRole } from \"@prisma/client\"\r\n\r\nconst SESSION_COOKIE = \"session_token\"\r\nconst SESSION_DURATION_MS = 1000 * 60 * 60 * 24 * 7\r\n\r\nfunction getSecret() {\r\n  const secret = process.env.JWT_SECRET\r\n  if (!secret) {\r\n    throw new Error(\"Missing JWT_SECRET\")\r\n  }\r\n  return new TextEncoder().encode(secret)\r\n}\r\n\r\nexport async function hashPassword(password: string) {\r\n  return bcrypt.hash(password, 10)\r\n}\r\n\r\nexport async function verifyPassword(password: string, hash: string) {\r\n  return bcrypt.compare(password, hash)\r\n}\r\n\r\nexport async function createAuthSession(userId: string, role: UserRole) {\r\n  const token = randomUUID()\r\n  const expiresAt = new Date(Date.now() + SESSION_DURATION_MS)\r\n\r\n  await prisma.session.create({\r\n    data: {\r\n      token,\r\n      userId,\r\n      expiresAt,\r\n    },\r\n  })\r\n\r\n  const jwt = await new SignJWT({ token, role })\r\n    .setProtectedHeader({ alg: \"HS256\" })\r\n    .setExpirationTime(expiresAt)\r\n    .sign(getSecret())\r\n\r\n  const cookieStore = await cookies()\r\n  cookieStore.set(SESSION_COOKIE, jwt, {\r\n    httpOnly: true,\r\n    sameSite: \"lax\",\r\n    expires: expiresAt,\r\n    path: \"/\",\r\n    secure: process.env.NODE_ENV === \"production\",\r\n  })\r\n  return token\r\n}\r\n\r\nexport async function clearSession() {\r\n  const cookieStore = await cookies()\r\n  const token = cookieStore.get(SESSION_COOKIE)?.value\r\n  if (token) {\r\n    await prisma.session.deleteMany({ where: { token } })\r\n  }\r\n  cookieStore.delete(SESSION_COOKIE)\r\n}\r\n\r\nexport async function getSessionUser() {\r\n  const cookieStore = await cookies()\r\n  const jwt = cookieStore.get(SESSION_COOKIE)?.value\r\n  if (!jwt) return null\r\n\r\n  try {\r\n    const { payload } = await jwtVerify(jwt, getSecret())\r\n    const token = payload.token as string\r\n    if (!token) return null\r\n    const session = await prisma.session.findUnique({\r\n      where: { token },\r\n      include: {\r\n        user: {\r\n          include: { organization: { select: { id: true, name: true, isRejected: true } } },\r\n        },\r\n      },\r\n    })\r\n    if (!session || session.expiresAt < new Date()) {\r\n      return null\r\n    }\r\n    if (session.user.status === \"suspended\") {\r\n      await prisma.session.deleteMany({ where: { token } })\r\n      cookieStore.delete(SESSION_COOKIE)\r\n      return null\r\n    }\r\n    return session.user\r\n  } catch {\r\n    return null\r\n  }\r\n}\r\n\r\nexport function requireRole(userRole: UserRole, allowed: UserRole[]) {\r\n  if (!allowed.includes(userRole)) {\r\n    return NextResponse.json({ error: \"Forbidden\" }, { status: 403 })\r\n  }\r\n  return null\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;AAGA,MAAM,iBAAiB;AACvB,MAAM,sBAAsB,OAAO,KAAK,KAAK,KAAK;AAElD,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;IACrC,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,IAAI,cAAc,MAAM,CAAC;AAClC;AAEO,eAAe,aAAa,QAAgB;IACjD,OAAO,+KAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,IAAY;IACjE,OAAO,+KAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,eAAe,kBAAkB,MAAc,EAAE,IAAc;IACpE,MAAM,QAAQ,IAAA,mHAAU;IACxB,MAAM,YAAY,IAAI,KAAK,KAAK,GAAG,KAAK;IAExC,MAAM,0JAAM,CAAC,OAAO,CAAC,MAAM,CAAC;QAC1B,MAAM;YACJ;YACA;YACA;QACF;IACF;IAEA,MAAM,MAAM,MAAM,IAAI,wMAAO,CAAC;QAAE;QAAO;IAAK,GACzC,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,iBAAiB,CAAC,WAClB,IAAI,CAAC;IAER,MAAM,cAAc,MAAM,IAAA,6KAAO;IACjC,YAAY,GAAG,CAAC,gBAAgB,KAAK;QACnC,UAAU;QACV,UAAU;QACV,SAAS;QACT,MAAM;QACN,QAAQ,oDAAyB;IACnC;IACA,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,6KAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,iBAAiB;IAC/C,IAAI,OAAO;QACT,MAAM,0JAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE;YAAM;QAAE;IACrD;IACA,YAAY,MAAM,CAAC;AACrB;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,6KAAO;IACjC,MAAM,MAAM,YAAY,GAAG,CAAC,iBAAiB;IAC7C,IAAI,CAAC,KAAK,OAAO;IAEjB,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,4MAAS,EAAC,KAAK;QACzC,MAAM,QAAQ,QAAQ,KAAK;QAC3B,IAAI,CAAC,OAAO,OAAO;QACnB,MAAM,UAAU,MAAM,0JAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE;YAAM;YACf,SAAS;gBACP,MAAM;oBACJ,SAAS;wBAAE,cAAc;4BAAE,QAAQ;gCAAE,IAAI;gCAAM,MAAM;gCAAM,YAAY;4BAAK;wBAAE;oBAAE;gBAClF;YACF;QACF;QACA,IAAI,CAAC,WAAW,QAAQ,SAAS,GAAG,IAAI,QAAQ;YAC9C,OAAO;QACT;QACA,IAAI,QAAQ,IAAI,CAAC,MAAM,KAAK,aAAa;YACvC,MAAM,0JAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gBAAE,OAAO;oBAAE;gBAAM;YAAE;YACnD,YAAY,MAAM,CAAC;YACnB,OAAO;QACT;QACA,OAAO,QAAQ,IAAI;IACrB,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,YAAY,QAAkB,EAAE,OAAmB;IACjE,IAAI,CAAC,QAAQ,QAAQ,CAAC,WAAW;QAC/B,OAAO,iLAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAY,GAAG;YAAE,QAAQ;QAAI;IACjE;IACA,OAAO;AACT"}},
    {"offset": {"line": 365, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Dew/404SquadSolarConnect/final/lib/services/auth.ts"],"sourcesContent":["import \"server-only\"\r\n\r\nimport bcrypt from \"bcryptjs\"\r\nimport { z } from \"zod\"\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { serializeUser } from \"@/lib/session\"\r\nimport { clearSession, createAuthSession, getSessionUser } from \"@/lib/auth-server\"\r\n\r\nconst registerSchema = z.object({\r\n  role: z.enum([\"customer\", \"installer\"]),\r\n  email: z.string().email(),\r\n  password: z.string().min(8),\r\n  name: z.string(),\r\n  phone: z.string().optional(),\r\n  address: z.string().optional(),\r\n  companyName: z.string().optional(),\r\n  description: z.string().optional(),\r\n})\r\n\r\nconst loginSchema = z.object({\r\n  email: z.string().email(),\r\n  password: z.string().min(1),\r\n})\r\n\r\nexport type PublicUser = ReturnType<typeof serializeUser>\r\n\r\nexport async function registerUser(input: unknown) {\r\n  const data = registerSchema.parse(input)\r\n\r\n  const existing = await prisma.user.findUnique({ where: { email: data.email } })\r\n  if (existing) {\r\n    throw new Error(\"An account with this email already exists\")\r\n  }\r\n\r\n  const passwordHash = await bcrypt.hash(data.password, 10)\r\n\r\n  let organizationId: string | undefined\r\n  if (data.role === \"installer\") {\r\n    const organization = await prisma.organization.create({\r\n      data: {\r\n        name: data.companyName || `${data.name}'s Solar`,\r\n        description: data.description,\r\n        verified: false,\r\n      },\r\n    })\r\n    organizationId = organization.id\r\n  }\r\n\r\n  const user = await prisma.user.create({\r\n    data: {\r\n      email: data.email,\r\n      name: data.name,\r\n      role: data.role,\r\n      status: \"active\",\r\n      phone: data.phone,\r\n      address: data.address,\r\n      passwordHash,\r\n      organizationId,\r\n      verified: data.role === \"customer\",\r\n    },\r\n    include: { organization: { select: { id: true, name: true, isRejected: true } } },\r\n  })\r\n\r\n  await createAuthSession(user.id, user.role)\r\n\r\n  return serializeUser(user)\r\n}\r\n\r\nexport async function loginUser(input: unknown) {\r\n  const data = loginSchema.parse(input)\r\n\r\n  const user = await prisma.user.findUnique({\r\n    where: { email: data.email },\r\n    include: { organization: { select: { id: true, name: true, isRejected: true } } },\r\n  })\r\n\r\n  if (!user) {\r\n    throw new Error(\"Invalid credentials\")\r\n  }\r\n\r\n  const isValid = await bcrypt.compare(data.password, user.passwordHash)\r\n  if (!isValid) {\r\n    throw new Error(\"Invalid credentials\")\r\n  }\r\n\r\n  await createAuthSession(user.id, user.role)\r\n  return serializeUser(user)\r\n}\r\n\r\nexport async function logoutUser() {\r\n  await clearSession()\r\n}\r\n\r\nexport async function currentUser() {\r\n  const user = await getSessionUser()\r\n  if (!user) return null\r\n\r\n  const fullUser = await prisma.user.findUnique({\r\n    where: { id: user.id },\r\n    include: { organization: { select: { id: true, name: true, isRejected: true } } },\r\n  })\r\n\r\n  return fullUser ? serializeUser(fullUser) : null\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Dew/404SquadSolarConnect/final/lib/fees.ts"],"sourcesContent":["import { promises as fs } from \"fs\"\r\nimport path from \"path\"\r\n\r\nconst DATA_DIR = path.join(process.cwd(), \"data\")\r\nconst FEES_PATH = path.join(DATA_DIR, \"fees.json\")\r\n\r\ntype FeeConfig = {\r\n  siteVisitFee: number\r\n}\r\n\r\nconst DEFAULT_FEES: FeeConfig = {\r\n  siteVisitFee: 1200,\r\n}\r\n\r\nasync function ensureFeesFile() {\r\n  try {\r\n    await fs.access(FEES_PATH)\r\n    return\r\n  } catch {}\r\n\r\n  await fs.mkdir(DATA_DIR, { recursive: true })\r\n  await fs.writeFile(FEES_PATH, JSON.stringify(DEFAULT_FEES, null, 2), \"utf8\")\r\n}\r\n\r\nexport async function getFees(): Promise<FeeConfig> {\r\n  await ensureFeesFile()\r\n  const content = await fs.readFile(FEES_PATH, \"utf8\")\r\n  return JSON.parse(content) as FeeConfig\r\n}\r\n\r\nexport async function updateFees(update: Partial<FeeConfig>): Promise<FeeConfig> {\r\n  const current = await getFees()\r\n  const next = { ...current, ...update }\r\n  await fs.writeFile(FEES_PATH, JSON.stringify(next, null, 2), \"utf8\")\r\n  return next\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAC1C,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,UAAU;AAMtC,MAAM,eAA0B;IAC9B,cAAc;AAChB;AAEA,eAAe;IACb,IAAI;QACF,MAAM,yGAAE,CAAC,MAAM,CAAC;QAChB;IACF,EAAE,OAAM,CAAC;IAET,MAAM,yGAAE,CAAC,KAAK,CAAC,UAAU;QAAE,WAAW;IAAK;IAC3C,MAAM,yGAAE,CAAC,SAAS,CAAC,WAAW,KAAK,SAAS,CAAC,cAAc,MAAM,IAAI;AACvE;AAEO,eAAe;IACpB,MAAM;IACN,MAAM,UAAU,MAAM,yGAAE,CAAC,QAAQ,CAAC,WAAW;IAC7C,OAAO,KAAK,KAAK,CAAC;AACpB;AAEO,eAAe,WAAW,MAA0B;IACzD,MAAM,UAAU,MAAM;IACtB,MAAM,OAAO;QAAE,GAAG,OAAO;QAAE,GAAG,MAAM;IAAC;IACrC,MAAM,yGAAE,CAAC,SAAS,CAAC,WAAW,KAAK,SAAS,CAAC,MAAM,MAAM,IAAI;IAC7D,OAAO;AACT"}},
    {"offset": {"line": 546, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Dew/404SquadSolarConnect/final/app/api/applications/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { Prisma } from \"@prisma/client\"\r\nimport { randomUUID } from \"crypto\"\r\nimport { promises as fs } from \"fs\"\r\nimport path from \"path\"\r\nimport { currentUser } from \"@/lib/services/auth\"\r\nimport { getFees } from \"@/lib/fees\"\r\n\r\nexport const runtime = \"nodejs\"\r\n\r\n/** Remove keys with undefined values (important for JSON fields) */\r\nfunction removeUndefined(obj: Record<string, unknown>) {\r\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined))\r\n}\r\n\r\nfunction mapApplication(application: any) {\r\n  const siteVisitInvoice = application.invoices?.find(\r\n    (invoice: any) =>\r\n      invoice.type === \"authority_fee\" && invoice.description === \"Site visit fee\"\r\n  )\r\n  const siteVisitFeePaid = siteVisitInvoice?.status === \"paid\"\r\n  const normalizedStatus =\r\n    siteVisitFeePaid && application.status === \"pre_visit_approved\"\r\n      ? \"site_visit_payment_completed\"\r\n      : application.status\r\n\r\n  return {\r\n    id: application.reference,\r\n    reference: application.reference,\r\n    status: normalizedStatus,\r\n    createdAt: application.createdAt,\r\n    updatedAt: application.updatedAt,\r\n    customerId: application.customerId,\r\n    customerName: application.customer.name,\r\n    email: application.customer.email,\r\n    phone: application.customer.phone,\r\n    address: application.customer.address,\r\n    documents: application.documents,\r\n    technicalDetails: application.technicalDetails,\r\n    siteVisitDate: application.siteVisitDate,\r\n    rejectionReason: application.rejectionReason,\r\n    siteVisitFeePaid,\r\n    selectedInstaller: application.installerOrganization\r\n      ? {\r\n          id: application.installerOrganization.id,\r\n          name: application.installerOrganization.name,\r\n          phone: application.installerOrganization.phone,\r\n          address: application.installerOrganization.address,\r\n          packageName: application.selectedPackage?.name,\r\n          price: application.selectedPackage?.price,\r\n        }\r\n      : undefined,\r\n    bidId: application.bids[0]?.id,\r\n    invoices: application.invoices,\r\n  }\r\n}\r\n\r\nexport async function GET() {\r\n  const user = await currentUser()\r\n  if (!user) {\r\n    return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\r\n  }\r\n\r\n  const applications = await prisma.application.findMany({\r\n    where:\r\n      user.role === \"customer\"\r\n        ? { customerId: user.id }\r\n        : user.role === \"installer\" && user.organization\r\n          ? { installerOrganizationId: user.organization.id }\r\n          : undefined,\r\n    include: {\r\n      customer: true,\r\n      installerOrganization: true,\r\n      selectedPackage: true,\r\n      bids: true,\r\n      invoices: true,\r\n    },\r\n    orderBy: { createdAt: \"desc\" },\r\n  })\r\n\r\n  return NextResponse.json({ applications: applications.map(mapApplication) })\r\n}\r\n\r\nexport async function POST(request: Request) {\r\n  const user = await currentUser()\r\n  if (!user) return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\r\n\r\n  if (user.role !== \"customer\") {\r\n    return NextResponse.json(\r\n      { error: \"Only customers can create applications\" },\r\n      { status: 403 }\r\n    )\r\n  }\r\n\r\n  let formData: FormData\r\n  try {\r\n    formData = await request.formData()\r\n  } catch {\r\n    return NextResponse.json({ error: \"Invalid form data\" }, { status: 400 })\r\n  }\r\n\r\n  const metaRaw = formData.get(\"meta\")\r\n  if (!metaRaw || typeof metaRaw !== \"string\") {\r\n    return NextResponse.json(\r\n      { error: \"Missing application details\" },\r\n      { status: 400 }\r\n    )\r\n  }\r\n\r\n  // âœ… FIX: confirmSingleSystem exists here because you use it later\r\n  const meta = JSON.parse(metaRaw) as {\r\n    siteAddress?: string\r\n    systemCapacity?: string\r\n    connectionPhase?: string\r\n    selectedPackageId?: string\r\n    installerOrganizationId?: string\r\n    purchaseMode?: \"direct\"\r\n    applicationId?: string\r\n    technicalDetails?: Record<string, unknown>\r\n    confirmSingleSystem?: boolean\r\n  }\r\n\r\n  const uploadsDir = path.join(process.cwd(), \"public\", \"uploads\")\r\n  await fs.mkdir(uploadsDir, { recursive: true })\r\n\r\n  async function persistFile(field: string) {\r\n    const file = formData.get(field)\r\n    if (!file || typeof file === \"string\") return undefined\r\n\r\n    const f = file as File\r\n    const arrayBuffer = await f.arrayBuffer()\r\n    const ext = path.extname(f.name || \"\") || \".bin\"\r\n    const storedName = `${randomUUID()}${ext}`\r\n    const storedPath = path.join(uploadsDir, storedName)\r\n    await fs.writeFile(storedPath, Buffer.from(arrayBuffer))\r\n\r\n    return {\r\n      fileName: f.name,\r\n      url: `/uploads/${storedName}`,\r\n      uploadedAt: new Date().toISOString(),\r\n    }\r\n  }\r\n\r\n  const documents = {\r\n    nic: await persistFile(\"nicDocument\"),\r\n    bankDetails: await persistFile(\"bankDetails\"),\r\n    electricityBill: await persistFile(\"electricityBill\"),\r\n    propertyDocument: await persistFile(\"propertyDocument\"),\r\n  }\r\n\r\n  const filteredDocuments = Object.fromEntries(\r\n    Object.entries(documents).filter(([, value]) => value)\r\n  )\r\n\r\n  const reference = `APP-${randomUUID().slice(0, 8).toUpperCase()}`\r\n\r\n  const paidFee = await prisma.invoice.findFirst({\r\n    where: {\r\n      customerId: user.id,\r\n      type: \"authority_fee\",\r\n      description: \"Site visit fee\",\r\n      status: \"paid\",\r\n    },\r\n    orderBy: { createdAt: \"desc\" },\r\n  })\r\n\r\n  const mode = new URL(request.url).searchParams.get(\"mode\")\r\n  const directPurchase = mode === \"direct\"\r\n\r\n  if (!directPurchase && !meta.confirmSingleSystem) {\r\n    return NextResponse.json(\r\n      {\r\n        error:\r\n          \"One application is limited to one solar system. Please confirm to proceed.\",\r\n      },\r\n      { status: 400 }\r\n    )\r\n  }\r\n\r\n  const include = {\r\n    customer: true,\r\n    installerOrganization: true,\r\n    selectedPackage: true,\r\n    bids: true,\r\n    invoices: true,\r\n  }\r\n\r\n  // Build technicalDetails without undefined values (JSON cannot contain undefined)\r\n  const baseTech = (meta.technicalDetails ?? {}) as Record<string, unknown>\r\n  const mergedTech = removeUndefined({\r\n    ...baseTech,\r\n    siteAddress: meta.siteAddress,\r\n    systemCapacity: meta.systemCapacity,\r\n    connectionPhase: meta.connectionPhase,\r\n  })\r\n\r\n  // schema requires Json (not optional) so always set an object\r\n  const technicalDetailsJson = mergedTech as Prisma.InputJsonValue\r\n\r\n  const documentsJson =\r\n    Object.keys(filteredDocuments).length > 0\r\n      ? (filteredDocuments as Prisma.InputJsonValue)\r\n      : ({} as Prisma.InputJsonValue)\r\n\r\n  // =========================\r\n  // DIRECT PURCHASE FLOW\r\n  // =========================\r\n  if (directPurchase) {\r\n    if (!meta.selectedPackageId) {\r\n      return NextResponse.json(\r\n        { error: \"Package is required for direct purchase\" },\r\n        { status: 400 }\r\n      )\r\n    }\r\n    if (!meta.applicationId) {\r\n      return NextResponse.json(\r\n        { error: \"Application is required for direct purchase\" },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    const pendingPayment = await prisma.application.findFirst({\r\n      where: { customerId: user.id, status: \"payment_pending\" },\r\n    })\r\n\r\n    if (pendingPayment && pendingPayment.reference !== meta.applicationId) {\r\n      return NextResponse.json(\r\n        { error: \"Complete your pending payment before buying another package\" },\r\n        { status: 409 }\r\n      )\r\n    }\r\n\r\n    const pkg = await prisma.installerPackage.findUnique({\r\n      where: { id: meta.selectedPackageId },\r\n    })\r\n\r\n    if (!pkg) {\r\n      return NextResponse.json({ error: \"Package not found\" }, { status: 404 })\r\n    }\r\n\r\n    // FIX: schema does NOT have pkg.active, so remove that check\r\n    // If you need activation later, add a boolean field in schema.\r\n\r\n    if (\r\n      meta.installerOrganizationId &&\r\n      meta.installerOrganizationId !== pkg.organizationId\r\n    ) {\r\n      return NextResponse.json(\r\n        { error: \"Installer does not match package\" },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    const existing = await prisma.application.findFirst({\r\n      where: { reference: meta.applicationId, customerId: user.id },\r\n      include,\r\n    })\r\n\r\n    if (!existing) {\r\n      return NextResponse.json({ error: \"Application not found\" }, { status: 404 })\r\n    }\r\n\r\n    // FIX: use UncheckedUpdateInput so you can set FK scalar IDs\r\n    const updateData: Prisma.ApplicationUncheckedUpdateInput = {\r\n      status: \"payment_pending\",\r\n      installerOrganizationId: pkg.organizationId,\r\n      selectedPackageId: pkg.id,\r\n\r\n      // Only update documents if new docs provided; otherwise keep existing\r\n      ...(Object.keys(filteredDocuments).length > 0 ? { documents: documentsJson } : {}),\r\n\r\n      // Always safe (JSON object)\r\n      technicalDetails: technicalDetailsJson,\r\n    }\r\n\r\n    const application = await prisma.application.update({\r\n      where: { id: existing.id },\r\n      data: updateData,\r\n      include,\r\n    })\r\n\r\n    const dueDate = new Date()\r\n    dueDate.setDate(dueDate.getDate() + 7)\r\n\r\n    const invoice = await prisma.invoice.create({\r\n      data: {\r\n        applicationId: application.id,\r\n        customerId: user.id,\r\n        amount: pkg.price,\r\n        description: \"Installer payment\",\r\n        dueDate,\r\n        status: \"pending\",\r\n        type: \"installation\",\r\n      },\r\n    })\r\n\r\n    return NextResponse.json(\r\n      { application: mapApplication(application), invoiceId: invoice.id },\r\n      { status: 201 }\r\n    )\r\n  }\r\n\r\n  // =========================\r\n  // NORMAL FLOW (SITE VISIT FEE)\r\n  // =========================\r\n  if (!paidFee) {\r\n    let pendingApp = await prisma.application.findFirst({\r\n      where: { customerId: user.id, status: \"pending\", siteVisitDate: null },\r\n      orderBy: { createdAt: \"desc\" },\r\n      include,\r\n    })\r\n\r\n    if (pendingApp) {\r\n      const updateData: Prisma.ApplicationUpdateInput = {\r\n        technicalDetails: technicalDetailsJson,\r\n        ...(Object.keys(filteredDocuments).length > 0 ? { documents: documentsJson } : {}),\r\n      }\r\n\r\n      pendingApp = await prisma.application.update({\r\n        where: { id: pendingApp.id },\r\n        data: updateData,\r\n        include,\r\n      })\r\n    } else {\r\n      pendingApp = await prisma.application.create({\r\n        data: {\r\n          reference,\r\n          customerId: user.id,\r\n          status: \"pending\",\r\n          documents: documentsJson,\r\n          technicalDetails: technicalDetailsJson,\r\n        },\r\n        include,\r\n      })\r\n    }\r\n\r\n    if (!pendingApp) {\r\n      return NextResponse.json({ error: \"Unable to create application\" }, { status: 500 })\r\n    }\r\n\r\n    if (mode === \"fee\") {\r\n      const fees = await getFees()\r\n      const dueDate = new Date()\r\n      dueDate.setDate(dueDate.getDate() + 7)\r\n\r\n      const invoice = await prisma.invoice.create({\r\n        data: {\r\n          applicationId: pendingApp.id,\r\n          customerId: user.id,\r\n          amount: fees.siteVisitFee,\r\n          description: \"Site visit fee\",\r\n          dueDate,\r\n          status: \"pending\",\r\n          type: \"authority_fee\",\r\n        },\r\n      })\r\n\r\n      return NextResponse.json(\r\n        {\r\n          error: \"Payment required\",\r\n          invoiceId: invoice.id,\r\n          applicationId: pendingApp.reference,\r\n          paymentRequired: true,\r\n        },\r\n        { status: 402 }\r\n      )\r\n    }\r\n\r\n    return NextResponse.json(\r\n      { application: mapApplication(pendingApp), paymentRequired: false },\r\n      { status: 201 }\r\n    )\r\n  }\r\n\r\n  // =========================\r\n  // NORMAL FLOW (FEE PAID -> CREATE NEW)\r\n  // =========================\r\n  const application = await prisma.application.create({\r\n    data: {\r\n      reference,\r\n      customerId: user.id,\r\n      status: \"pending\",\r\n      documents: documentsJson,\r\n      technicalDetails: technicalDetailsJson,\r\n    },\r\n    include,\r\n  })\r\n\r\n  return NextResponse.json({ application: mapApplication(application) }, { status: 201 })\r\n}"],"names":[],"mappings":"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"}}]
}